### 0. 提交Github地址

> https://github.com/IvyZh/JavaSE_Basic.git


### 1. 小白使用eclipse提交到GitHub (详细步骤)

> https://blog.csdn.net/bendanany/article/details/78891804


### 2. 以下代码运行不报错

	System.out.println(0 / 0.0);//NaN
	System.out.println(1 / 0.0);//Infinity
	System.out.println(-1 / 0.0);//-Infinity

### 3. 实例化和初始化的区别
实例化一般是由类创建的对象，在构造一个实例的时候需要在内存中开辟空间，即   Student   s = new Student();

初始化   实例化的基础上，并且对 对象中的值进行赋一下初始值


###4. 在for循环嵌套优化这个Demo中

优化前耗时： 5305 5039 5279 5026

第一层优化耗时：5439 5760 5549 5483

第二层优化耗时：5416 5356 5459 5415

为什么这么不明显？反而耗时更长？？？

### 5. 一些术语

- 参数列表: 参数的类型 + 参数的个数  + 参数的顺序.

- 方法签名: 方法名称  +  方法参数列表;(在同一个类中,方法签名是唯一的,否则编译报错.)

- 方法重载：两同以不同，同一个类中，方法名相同，参数列表不同。屏蔽了同一功能的方法由于参数不同所造成方法名不同。


### 6. JVM内存模型！！！

JVM内存划分,人为的根据不同内存空间的存储特点以及存储的数据（逻辑分区）:
程序计数器：当前线程所执行的字节码的行号指示器。
本地方法栈：为虚拟机使用的native方法服务。
Java虚拟机栈：描述Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。
     每一个方法,创建一个栈帧,栈帧存放了当前方法的数据信息(局部变量),当方法调用完毕,该方法的栈帧就被销毁了.
Java堆：被所有线程共享的一块内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配(使用new关键字,就表示在堆中开辟一块新的存储空间)。
方法区：线程共享的内存区域，存储已被虚拟机加载的类信息、常量、静态变量即时编译器编译后的代码数据等(这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载)。


GC(Garbage Collection):垃圾回收器。
Java的自动垃圾回收机制:简单理解为,
程序员就不需要再手动的去控制内存的释放。当JVM发觉内存资源紧张的时候，就会自动地去清理无用对象（没有被引用到的对象）所占用的内存空间。
数组/面向对象再讲.