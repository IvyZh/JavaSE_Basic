package com.ivy.github.day08;

//方法覆写的原则（一同两小一大）：Override
//一同：
//①　实例方法签名必须相同。 (方法签名= 方法名 + 方法的参数列表)
//两小：
//②　子类方法的返回值类型是和父类方法的返回类型相同或者是其子类。
//              子类可以返回一个更加具体的类.
//③　子类方法声明抛出的异常类型和父类方法声明抛出的异常类型相同或者是其子类。
//ü子类方法中声明抛出的异常小于或等于父类方法声明抛出异常类型；
//ü子类方法可以同时声明抛出多个属于父类方法声明抛出异常类的子类(RuntimeException类型除外)；
//一大：
//④　子类方法的访问权限比父类方法访问权 限更大或相等。
//private修饰的方法不能被子类所继承,也就不存在覆盖的概念.
//判断是否是覆写方法的必杀技：@Override标签：若方法是覆写方法，在方法前或上贴上该标签， 编译通过，否则，编译出错。
//只有方法存在覆盖的概念,字段没有覆盖.
//方法覆盖解决的问题:  当父类的某一个行为不符合子类具体的特征的时候,此时子类需要重新定义父类的方法,并重写方法体.

//方法重载和方法覆盖(方法重写)的区别:
//方法重载: Overload
//方法重写: Override
//批判,本身二者一点关系都没有,仅仅只是因为名字很像.
//-------------------------------------------------------------------
//方法重载: Overload
//   作用: 解决了同一个类中,相同功能的方法名不同的问题.
//               既然是相同的功能,那么方法的名字就应该相同.
//    规则: 两同一不同.
//              同类中,方法名相同,方法参数列表不同(参数类型,参数个数,参数顺序).
//方法重写: Override
//   作用:解决子类继承父类之后,可能父类的某一个方法不满足子类的具体特征,此时需要重新在子类中定义该方法,并重写方法体.
//   规则: 一同两小,一大.
//            一同:父类和子类的方法签名是相同的,所以,建议:直接拷贝父类中方法的定义到子类中,再重写方法体,就OK了.
//
//方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。
//注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符。

public class OverrideDemo {

}
