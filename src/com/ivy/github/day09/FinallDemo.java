package com.ivy.github.day09;

//为什么得需要使用final修饰符:
//    继承关系最大弊端是破坏封装:子类能访问父类的实现细节,而且可以通过方法覆盖的形式修改实现细节.

//final本身的含义是“最终的,不可改变的”，它可以修饰非抽象类，非抽象方法和变量。注意：构造方法不能使用final修饰，因为构造方法不能被继承，肯定是最终的。
//final修饰的类: 表示最终的类, 该类不能再有子类.
//只要满足以下条件就可以把一个类设计成final类：
//①　某类不是专门为继承而设计。
//②　出于安全考虑，类的实现细节不许改动,不准修改源代码。
//③　确信该类不会再被拓展。
//面试题:列举5个Java中内置的使用final修饰的类.
//java里final修饰的类有很多，比如八大基本数据类型包装类和String等。
//-----------------------------------------
//final修饰的方法:  最终的方法,该方法不能被子类覆盖.
//什么时候的方法需要使用final修饰.
//          1):在父类中提供的统一的算法骨架,不准子类通过方法覆盖来修改. 此时使用final修饰.模板方法设计模式.
//          2):在构造器中调用的方法(初始化方法),此时一般使用final修饰.
//注意: final修饰的方法,子类可以调用,但是不能覆盖.
//-----------------------------------------
//final修饰的变量: 最终的变量,常量,该变量只能赋值一次,不能再赋值.
//         final是唯一可以修饰局部变量的修饰符.

//常量分类:
//    1):字面值常量(直接给出的数据值/直接量):比如：整数常量1，2，3，小数常量3.14，布尔常量false，true等。
//    2):定义的final变量:
//
//final修饰的变量:表示常量,只能赋值一次,不能在赋值.
//-----------------------------------------------------------------------------------------
//1):final变量必须显示地指定初始值，系统不会为final字段初始化。
//2):final变量一旦赋予初始值，就不能被重新赋值。
//3):常量名规范：常量名符合标识符，单词全部使用大写字母，如果是多个单词组成,单词间使用下划线隔开。
//  int类型的最大值:  final int MAX_VALUE = ....;
//  补充概念:全局静态常量: public  static  final 修饰的变量,直接使用类名调用即可.

//-----------------------------------------------------------------------------------------
//面试题: final修饰的引用类型变量到底表示引用的地址不能改变,还是引用空间中的数据不能改变.
//final修饰基本类型变量：表示该变量的值不能改变，即不能用“=”号重新赋值。
//final修饰引用类型变量：表示该变量的引用的地址不能变，而不是引用地址里的内容不能变。
//-----------------------------------------------------------------------------------------
//final是唯一可以修饰局部变量的修饰符,目的何在?期待局部内部类.局部内部类只能访问final修饰的局部变量
//什么时候使用常量:
//    当在程序中,多个地方使用到共同的数据,且该数据不会改变,此时我们专门定义全局的常量,
//    一般的,我们在开发中会专门定义一个常量类,专门用来存储常量数据.

public class FinallDemo {

}
